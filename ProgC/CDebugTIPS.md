# C言語デバッグTIPS

## はじめに
この記事ではC言語のプログラミングで「コンパイルは通ったけど何故かちゃんと動かない」「どこでSegmentation Faultが起こっているのか分からない」などのトラブルが発生した際により効率よく原因を特定するためのTIPSを紹介します。

デバッグ用のツールにgdb等がありますが、ここでは誰でもすぐ活かせるようツールを使わないデバッグを中心に扱います。

なお、コンパイル自体が通らないという場合は[C言語エラー集](https://ofls.github.io/PublicMaterial/ProgC/CErrorTIPS.html)を参照してください。

## C言語以外の言語について
このTIPSではあくまでC言語を前提としています。C++でも同様のテクニックは使えますがもともとデバッグのためのより便利な機能が備わっています。
JavaやPythonなどは異常終了の際に原因が丁寧に出力されるためこのTIPSの内容はほぼ不要となります。

## Segmentation Fault編

###  printf()デバッグが通用しないパターン

怪しそうな箇所にprintf()を記述して値を確認したり、あるいはその行に到達できているかをチェックすることは多いと思います。

ですがプログラムが正しく動かない原因がSegmentation Faultの場合、既に通過したはずのprintf()でもターミナルに表示される保証はありません（多分5%くらい失敗する）。このような場合に出力を過信すると原因箇所の特定が遅れます。

そこでreturnあるいはexit()（exit()はstdlib.hが必要）を使って原因箇所の特定をします。怪しい箇所の直前でreturnをしてSegmentation Faultが起こらないならその後が原因という判断ができます。
```
int main() {
    //略

    function1();
    printf("ここまで動いた"); //このあとコアダンプした場合このメッセージが表示される保証はない
    return 0; //このreturnを消すとコアダンプするならこの後が原因
    function2();
    return 0;
}

```

### 何もしていないのにSegmentation Faultした

上記の方法を使って怪しい箇所の絞り込みをおこなった結果「main()の最初の処理の前に異常終了している」ことが明らかになることがあります。

この場合の主な原因は変数の宣言の問題です。

```
int main() {
    int a[10000000];

    return; //ここにreturnがあってもコアダンプするなら変数の宣言を疑う
    function1();
    function2();
}
```

スタック領域で使用できるメモリサイズの制約は厳しく、ある程度大きな配列を関数内で宣言すると実行した瞬間にコアダンプします。

どうしてもそのようなサイズの配列が必要であればmallocを使うかグローバル変数として宣言しましょう（ヒープ領域とデータ領域はサイズの制約が緩いため）。

## バッファオーバーラン編
Segmentation Faultは起こっていないものの明らかに挙動がおかしい、より具体的には「明らかに触っていない変数の値が勝手に書き換わっている気がする」などの怪現象が発生した際に考えられる原因について考えます。

### メモリ破壊の例
```
char str[7];
```
という配列があるとします。

ここにabcdefgのような7文字の文字列を入力しようとするとヌル文字が配列の外にはみ出てしまいます。

そのような場合にSegmentation Faultになるかどうかは他の変数がどのアドレスに配置されているか等によります。厄介なのはSegmentation Faultにならなかった場合で、この場合はみ出た場所にもともとあったデータを書き換えています。

### 対処法
バッファオーバーランが疑わしいときは配列のサイズを十分確保しましょう。大体はヌル文字の考慮漏れなので1増やせば済むことが多いです。いっそのこと倍くらいでも良いです。それで解決した場合は大体バッファオーバーランによるメモリ破壊が原因です。

### （怪現象）printf()を消すと動かなくなる
よく怪現象扱いされているバグに以下のようなものがあります。自分も現物を見たことがあります。
```
printf("OK\n"); //これを消すと動かなくなるので消さないこと
```

基本的にはこれもメモリ破壊を疑います。各変数がメモリ上のどこに配置されるかは例えば「printfでどのような文字列を出力させるか」などの些細な理由でも変わります。

上の例の場合、どこかで発生していたメモリ破壊がたまたまprintf("OK\n")があるときは実害がない場所で起こっていたと考えられます。

怪現象と片付ける前にどこか処理自体に致命的な間違いがないかよくチェックしましょう。

## その他のTIPS
### 再帰のデバッグ
ただでさえ動きを理解しにくい再帰処理のデバッグについてです。

単なるループであればカウンタ変数の値をprintfで出力すれば今何回目なのかが簡単に分かりますが、再帰では今どの深さにいるのかは意識的に値として持たせないと表示させることができません。

デバッグの観点としては再帰関数の引数にとりあえず深さの情報を持たせるのが有効です。これで予定よりも遥かに深くまで再帰が行われているのか、あるいは必要な深さまで到達していないのかなどが分かります。

```
//処理自体はdata1,data2があれば可能であるとする
void rec(int data1, int data2, int depth){
    printf("depth %d\n", depth); //今の再帰の深さがわかる

    //.....

    rec(data3, data4, depth + 1);
}
```

## お知らせ

修学支援室では「授業で難しく感じたところ」に関するアンケートを実施中です。
全てではありませんがこんな風に記事になる可能性がありますのでぜひ調査にご協力いただければと思います。

[授業で難しかったところについてのアンケート](https://docs.google.com/forms/d/e/1FAIpQLScWKlr5Q9ctfumYM_BZsII-UX1ToD6e8-OLpqSH8biI9AJ7Gg/viewform?usp=sf_link)
